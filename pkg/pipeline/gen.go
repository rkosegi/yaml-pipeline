// Package pipeline provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package pipeline

import (
	"os"
	"regexp"

	"github.com/rkosegi/yaml-toolkit/patch"
)

// Defines values for ErrorPropagationPolicy.
const (
	ErrorPropagationPolicyIgnore ErrorPropagationPolicy = "ignore"
)

// Defines values for Html2DomLayout.
const (
	Html2DomLayoutDefault Html2DomLayout = "default"
)

// Defines values for OutputFormat.
const (
	OutputFormatJson       OutputFormat = "json"
	OutputFormatProperties OutputFormat = "properties"
	OutputFormatText       OutputFormat = "text"
	OutputFormatYaml       OutputFormat = "yaml"
)

// Defines values for ParseFileMode.
const (
	ParseFileModeBinary     ParseFileMode = "binary"
	ParseFileModeJson       ParseFileMode = "json"
	ParseFileModeProperties ParseFileMode = "properties"
	ParseFileModeText       ParseFileMode = "text"
	ParseFileModeXml        ParseFileMode = "xml"
	ParseFileModeYaml       ParseFileMode = "yaml"
)

// Defines values for ParseTextAs.
const (
	ParseTextAsFloat64 ParseTextAs = "float64"
	ParseTextAsInt64   ParseTextAs = "int64"
	ParseTextAsNone    ParseTextAs = "none"
	ParseTextAsYaml    ParseTextAs = "yaml"
)

// Defines values for SetStrategy.
const (
	SetStrategyMerge   SetStrategy = "merge"
	SetStrategyReplace SetStrategy = "replace"
)

// Defines values for XmlLayout.
const (
	XmlLayoutDefault XmlLayout = "default"
)

// AbortOpSpec AbortOp can be used to abort execution
type AbortOpSpec struct {
	// Message The reason of abort
	Message string `json:"message" yaml:"message"`
}

// ActionMeta defines model for actionMeta.
type ActionMeta struct {
	// ErrorPropagation ErrorPropagation configure behavior of error propagation.
	//  * ignore - error is silently ignored
	ErrorPropagation *ErrorPropagationPolicy `json:"errorPropagation,omitempty" yaml:"errorPropagation,omitempty"`

	// Name Name of this step, should be unique within the current scope
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`

	// Order Optional ordinal number that controls order of execution within parent step
	Order *int `json:"order,omitempty" yaml:"order,omitempty"`

	// When Optional expression to make execution of this action conditional. Execution of this step is skipped when this expression is evaluated to false. If value of this field is omitted, then this action is executed
	When *string `json:"when,omitempty" yaml:"when,omitempty"`
}

// CallOpSpec defines model for callOpSpec.
type CallOpSpec struct {
	// Args Arguments to be passed to callable.
	// Leaf values are recursively templated just before call is executed.
	Args *map[string]interface{} `json:"args,omitempty" yaml:"args,omitempty"`

	// ArgsPath ArgsPath is optional path within the global data where arguments are stored prior to execution. When omitted, then default value of "args" is assumed. Note that passing arguments to nested callable is only possible if path is different, otherwise inner's arguments will overwrite outer's one. Template is accepted as possible value.
	ArgsPath *string `json:"argsPath,omitempty" yaml:"argsPath,omitempty"`

	// Name Name is name of callable previously registered using DefineOp.
	// Attempt to use name that was not registered will result in error
	Name string `json:"name" yaml:"name"`
}

// DefineOpSpec DefineOp can be used to define the ActionSpec and later recall it by name via CallOp.
// Attempt to define name that was defined before will result in an error.
type DefineOpSpec struct {
	Action ActionSpec `json:"action" yaml:"action"`

	// Name Name that will be used for registration
	Name string `json:"name" yaml:"name"`
}

// EnvOpSpec This op is used to import OS environment variables into data
type EnvOpSpec struct {
	// Exclude Optional regexp which defines what to exclude.
	// Only item names NOT matching this regexp are added into data document.
	// Exclusion is considered after inclusion regexp is processed.
	Exclude *regexp.Regexp `json:"exclude,omitempty" yaml:"exclude,omitempty"`

	// Include Optional regexp which defines what to include.
	// Only item names matching this regexp are added into data document.
	Include *regexp.Regexp `json:"include,omitempty" yaml:"include,omitempty"`

	// Path Optional path within data tree under which "Env" container will be put. When omitted, then "Env" goes to root of data.
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`
}

// ErrorPropagationPolicy ErrorPropagation configure behavior of error propagation.
//   - ignore - error is silently ignored
type ErrorPropagationPolicy string

// ExecOpSpec defines model for execOpSpec.
type ExecOpSpec struct {
	// Args Optional arguments for program
	Args *[]string `json:"args,omitempty" yaml:"args,omitempty"`

	// Dir Program's working directory
	Dir *string `json:"dir,omitempty" yaml:"dir,omitempty"`

	// Program Program to execute
	Program string `json:"program" yaml:"program"`

	// SaveExitCodeTo Path within the global data where to set exit code.
	SaveExitCodeTo *string `json:"saveExitCodeTo,omitempty" yaml:"saveExitCodeTo,omitempty"`

	// Stderr Path to file where program's stderr will be written upon completion.
	// Any error occurred during write will result in error.
	Stderr *string `json:"stderr,omitempty" yaml:"stderr,omitempty"`

	// Stdout Path to file where program's stdout will be written upon completion.
	// Any error occurred during write will result in error.
	Stdout *string `json:"stdout,omitempty" yaml:"stdout,omitempty"`

	// ValidExitCodes List of exit codes that are assumed to be valid
	ValidExitCodes *[]int `json:"validExitCodes,omitempty" yaml:"validExitCodes,omitempty"`
}

// ExportOpSpec defines model for exportOpSpec.
type ExportOpSpec struct {
	// File File to export data onto
	File *ValOrRef `json:"file" yaml:"file"`

	// Format Format of output file
	Format OutputFormat `json:"format" yaml:"format"`

	// Path Path within data tree pointing to dom.Node to export. Empty path denotes whole document.
	// If path does not resolve, then empty document will be exported.
	// If output format is "text" then path must point to leaf.
	// Any other output format must point to dom.Container.
	// If neither of these conditions are met, then it is considered as if path does not resolve at all.
	Path *ValOrRef `json:"path,omitempty" yaml:"path,omitempty"`
}

// ExtOpSpec defines model for extOpSpec.
type ExtOpSpec struct {
	// Args holds arguments to be passed to function
	Args *map[string]interface{} `json:"args,omitempty" yaml:"args,omitempty"`

	// Function Name of the function that was registered with the Executor
	Function string `json:"function" yaml:"function"`
}

// ForEachOpSpec ForEachOp can be used to repeat actions over list of items.
// Those items could be
//   - files specified by globbing pattern
//   - result of query from data tree (list values)
//   - specified strings
type ForEachOpSpec struct {
	Action ActionSpec `json:"action" yaml:"action"`

	// Glob Glob is pattern that will be used to match files on file system.
	// Matched files will be used as iteration items.
	Glob *ValOrRef `json:"glob,omitempty" yaml:"glob,omitempty"`

	// Item Item is list of specified strings to iterate over
	Item *ValOrRefSlice `json:"item,omitempty" yaml:"item,omitempty"`

	// Query Query is path within the data tree that will be attempted
	Query *ValOrRef `json:"query,omitempty" yaml:"query,omitempty"`

	// Variable Variable is name of variable to hold current iteration item.
	// When omitted, default value of "forEach" will be used
	Variable *string `json:"variable,omitempty" yaml:"variable,omitempty"`
}

// Html2DomLayout Layout defines how HTML-specific constructs are laid out into DOM tree.
//   - default - will produce "Value" leaf for each text node.
//     Child elements are collected into the list, if their name appears multiple times within the parent, otherwise they are regular child node.
//     Attributes of element are put into container node "Attrs".
//     Namespaces are ignored.
type Html2DomLayout string

// Html2DomOpSpec Allow for conversion of XML/HTML source DOM tree.
// This is now deprecated and ImportOp with XML mode should be used instead.
type Html2DomOpSpec struct {
	// From path within the global data to the leaf node where XML source is stored as string
	From string `json:"from" yaml:"from"`

	// Layout Layout defines how HTML-specific constructs are laid out into DOM tree.
	//  * default - will produce "Value" leaf for each text node.
	//  Child elements are collected into the list, if their name appears multiple times within the parent, otherwise they are regular child node.
	//  Attributes of element are put into container node "Attrs".
	//  Namespaces are ignored.
	Layout *Html2DomLayout `json:"layout,omitempty" yaml:"layout,omitempty"`

	// Query optional xpath expression to use to extract subset from source XML document
	Query *ValOrRef `json:"query,omitempty" yaml:"query,omitempty"`

	// To destination where to put converted document as dom.Container
	To string `json:"to" yaml:"to"`
}

// ImportOpSpec defines model for importOpSpec.
type ImportOpSpec struct {
	// File File to read data from
	File string `json:"file" yaml:"file"`

	// Mode ParseFileMode defines how the file is parsed before is put into data tree
	//  * binary - File is read and encoded using base64 string into data tree
	//  * text - File is read as-is and is assumed it represents utf-8 encoded byte stream
	//  * yaml - File is parsed as YAML document and put as child node into data tree
	//  * xml - File is parsed as XML document and transformed using selected layout.
	//  * json - File is parsed as JSON document and put as child node into data tree
	//  * properties - File is parsed as Java properties into map[string]interface{} and put as child node into data tree
	Mode ParseFileMode `json:"mode" yaml:"mode"`

	// Path Path at which to import the data.
	Path string `json:"path" yaml:"path"`

	// Xml Configuration to customize XML loading. Only relevant for 'xml' mode
	Xml *XmlImportOptions `json:"xml,omitempty" yaml:"xml,omitempty"`
}

// LogOpSpec LogOp just logs message to logger
type LogOpSpec struct {
	// Message Message to log
	Message string `json:"message" yaml:"message"`
}

// LoopOpSpec LoopOp is similar to ForEach, but it also has initial and post actions
type LoopOpSpec struct {
	Action     ActionSpec  `json:"action" yaml:"action"`
	Init       *ActionSpec `json:"init,omitempty" yaml:"init,omitempty"`
	PostAction *ActionSpec `json:"postAction,omitempty" yaml:"postAction,omitempty"`

	// Test Test is condition that is tested before each iteration.
	// When evaluated to true, execution will proceed with next iteration, false terminates loop immediately
	Test string `json:"test" yaml:"test"`
}

// OpSpec defines model for opSpec.
type OpSpec struct {
	// Abort AbortOp can be used to abort execution
	Abort *AbortOpSpec `json:"abort,omitempty" yaml:"abort,omitempty"`
	Call  *CallOpSpec  `json:"call,omitempty" yaml:"call,omitempty"`

	// Define DefineOp can be used to define the ActionSpec and later recall it by name via CallOp.
	// Attempt to define name that was defined before will result in an error.
	Define *DefineOpSpec `json:"define,omitempty" yaml:"define,omitempty"`

	// Env This op is used to import OS environment variables into data
	Env    *EnvOpSpec    `json:"env,omitempty" yaml:"env,omitempty"`
	Exec   *ExecOpSpec   `json:"exec,omitempty" yaml:"exec,omitempty"`
	Export *ExportOpSpec `json:"export,omitempty" yaml:"export,omitempty"`
	Ext    *ExtOpSpec    `json:"ext,omitempty" yaml:"ext,omitempty"`

	// ForEach ForEachOp can be used to repeat actions over list of items.
	// Those items could be
	//  * files specified by globbing pattern
	//  * result of query from data tree (list values)
	//  * specified strings
	ForEach *ForEachOpSpec `json:"forEach,omitempty" yaml:"forEach,omitempty"`

	// Html2dom Allow for conversion of XML/HTML source DOM tree.
	// This is now deprecated and ImportOp with XML mode should be used instead.
	Html2dom *Html2DomOpSpec `json:"html2dom,omitempty" yaml:"html2dom,omitempty"`
	Import   *ImportOpSpec   `json:"import,omitempty" yaml:"import,omitempty"`

	// Log LogOp just logs message to logger
	Log *LogOpSpec `json:"log,omitempty" yaml:"log,omitempty"`

	// Loop LoopOp is similar to ForEach, but it also has initial and post actions
	Loop *LoopOpSpec `json:"loop,omitempty" yaml:"loop,omitempty"`

	// Os OS operation spec
	Os *OsOpSpec `json:"os,omitempty" yaml:"os,omitempty"`

	// Patch PatchOp performs RFC6902-style patch on global data document.
	Patch *PatchOpSpec `json:"patch,omitempty" yaml:"patch,omitempty"`
	Set   *SetOpSpec   `json:"set,omitempty" yaml:"set,omitempty"`

	// Template TemplateOp can be used to render value from data at runtime
	Template *TemplateOpSpec `json:"template,omitempty" yaml:"template,omitempty"`

	// TemplateFile TemplateFileOp can be used to render template from file and write result to output.
	TemplateFile *TemplateFileOpSpec `json:"templateFile,omitempty" yaml:"templateFile,omitempty"`
}

// OsFileMode POSIX file mode/permission
type OsFileMode = os.FileMode

// OsFilePath Arbitrary file path
type OsFilePath = ValOrRef

// OsOpChdirSpec Change working directory
type OsOpChdirSpec struct {
	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`
}

// OsOpChmodSpec Change file mode/permission
type OsOpChmodSpec struct {
	// Mode POSIX file mode/permission
	Mode OsFileMode `json:"mode" yaml:"mode"`

	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`
}

// OsOpCopySpec Copy file(s) from source path to the destination
type OsOpCopySpec struct {
	// From Arbitrary file path
	From OsFilePath `json:"from" yaml:"from"`

	// To Arbitrary file path
	To OsFilePath `json:"to" yaml:"to"`
}

// OsOpGetcwdSpec Gets current working directory
type OsOpGetcwdSpec struct {
	// StoreTo Path to location within the data, where result of operation is store upon success
	StoreTo StoreResultTo `json:"storeTo" yaml:"storeTo"`
}

// OsOpHostnameSpec Gets system hostname
type OsOpHostnameSpec struct {
	// StoreTo Path to location within the data, where result of operation is store upon success
	StoreTo StoreResultTo `json:"storeTo" yaml:"storeTo"`
}

// OsOpLinkSpec Create link from old file to new file
type OsOpLinkSpec struct {
	// NewName Arbitrary file path
	NewName OsFilePath `json:"newName" yaml:"newName"`

	// OldName Arbitrary file path
	OldName OsFilePath `json:"oldName" yaml:"oldName"`

	// Symbolic When true, link will be symbolic, otherwise it will be hardlink
	Symbolic bool `json:"symbolic" yaml:"symbolic"`
}

// OsOpMkdirSpec Create directory
type OsOpMkdirSpec struct {
	// Mode POSIX file mode/permission
	Mode *OsFileMode `json:"mode,omitempty" yaml:"mode,omitempty"`

	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`

	// Recursive Whether to apply operation recursively
	Recursive *RecursiveFlag `json:"recursive,omitempty" yaml:"recursive,omitempty"`
}

// OsOpReadDirSpec Read file entries in directory
type OsOpReadDirSpec struct {
	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`

	// StoreTo Path to location within the data, where result of operation is store upon success
	StoreTo StoreResultTo `json:"storeTo" yaml:"storeTo"`
}

// OsOpRemoveSpec Remove a file
type OsOpRemoveSpec struct {
	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`

	// Recursive Whether to apply operation recursively
	Recursive *RecursiveFlag `json:"recursive,omitempty" yaml:"recursive,omitempty"`
}

// OsOpSpec OS operation spec
type OsOpSpec struct {
	// Chdir Change working directory
	Chdir *OsOpChdirSpec `json:"chdir,omitempty" yaml:"chdir,omitempty"`

	// Chmod Change file mode/permission
	Chmod *OsOpChmodSpec `json:"chmod,omitempty" yaml:"chmod,omitempty"`

	// Copy Copy file(s) from source path to the destination
	Copy *OsOpCopySpec `json:"copy,omitempty" yaml:"copy,omitempty"`

	// Getcwd Gets current working directory
	Getcwd *OsOpGetcwdSpec `json:"getcwd,omitempty" yaml:"getcwd,omitempty"`

	// Hostname Gets system hostname
	Hostname *OsOpHostnameSpec `json:"hostname,omitempty" yaml:"hostname,omitempty"`

	// Link Create link from old file to new file
	Link *OsOpLinkSpec `json:"link,omitempty" yaml:"link,omitempty"`

	// Mkdir Create directory
	Mkdir *OsOpMkdirSpec `json:"mkdir,omitempty" yaml:"mkdir,omitempty"`

	// Readdir Read file entries in directory
	Readdir *OsOpReadDirSpec `json:"readdir,omitempty" yaml:"readdir,omitempty"`

	// Remove Remove a file
	Remove *OsOpRemoveSpec `json:"remove,omitempty" yaml:"remove,omitempty"`

	// Stat Gets a file info
	Stat *OsOpStatSpec `json:"stat,omitempty" yaml:"stat,omitempty"`

	// Userhome Gets users' home directory path
	Userhome *OsOpUserHomeSpec `json:"userhome,omitempty" yaml:"userhome,omitempty"`
}

// OsOpStatSpec Gets a file info
type OsOpStatSpec struct {
	// Path Arbitrary file path
	Path OsFilePath `json:"path" yaml:"path"`

	// StoreTo Path to location within the data, where result of operation is store upon success
	StoreTo StoreResultTo `json:"storeTo" yaml:"storeTo"`
}

// OsOpUserHomeSpec Gets users' home directory path
type OsOpUserHomeSpec struct {
	// StoreTo Path to location within the data, where result of operation is store upon success
	StoreTo StoreResultTo `json:"storeTo" yaml:"storeTo"`
}

// OutputFormat Format of output file
type OutputFormat string

// ParseFileMode ParseFileMode defines how the file is parsed before is put into data tree
//   - binary - File is read and encoded using base64 string into data tree
//   - text - File is read as-is and is assumed it represents utf-8 encoded byte stream
//   - yaml - File is parsed as YAML document and put as child node into data tree
//   - xml - File is parsed as XML document and transformed using selected layout.
//   - json - File is parsed as JSON document and put as child node into data tree
//   - properties - File is parsed as Java properties into map[string]interface{} and put as child node into data tree
type ParseFileMode string

// ParseTextAs ParseTextAs defines how to parse text.
//   - none - do not parse, it's just a text (dom.Leaf)
//   - yaml - parse text as a YAML source into dom.Node
//   - float64 - parse text as float64 number into dom.Leaf
//   - int64 - parse text as int64 number into dom.Leaf
type ParseTextAs string

// PatchOpSpec PatchOp performs RFC6902-style patch on global data document.
type PatchOpSpec struct {
	// From Path used as a source with Copy and Move operations
	From *string `json:"from,omitempty" yaml:"from,omitempty"`

	// Op Op is RFC6902 operation
	Op patch.Op `json:"op" yaml:"op"`

	// Path Path is used as general path for every operation
	Path string `json:"path" yaml:"path"`

	// Value Value to be used for op. This takes precedence over ValueFrom.
	Value *AnyVal `json:"value,omitempty" yaml:"value,omitempty"`

	// ValueFrom Allow a value to be read from data tree at given path.
	//  Only considered when Value is not specified
	ValueFrom *string `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty"`
}

// RecursiveFlag Whether to apply operation recursively
type RecursiveFlag = bool

// SetOpSpec defines model for setOpSpec.
type SetOpSpec struct {
	// Data Arbitrary data to put into data tree
	Data map[string]interface{} `json:"data" yaml:"data"`

	// Path Path at which to put data.
	// If omitted, then data are merged into root of document
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`

	// Render Flag indicating use of templating. When true, data are passed through template engine
	Render *bool `json:"render,omitempty" yaml:"render,omitempty"`

	// Strategy Defines how data are handled when conflict occurs during set.
	//  * replace - old value is replaced with new.
	//  * merge - merge is attempted by applying new value on top of old one.
	Strategy *SetStrategy `json:"strategy,omitempty" yaml:"strategy,omitempty"`
}

// SetStrategy Defines how data are handled when conflict occurs during set.
//   - replace - old value is replaced with new.
//   - merge - merge is attempted by applying new value on top of old one.
type SetStrategy string

// StoreResultTo Path to location within the data, where result of operation is store upon success
type StoreResultTo = ValOrRef

// TemplateFileOpSpec TemplateFileOp can be used to render template from file and write result to output.
type TemplateFileOpSpec struct {
	// File Path to file with template
	File string `json:"file" yaml:"file"`

	// Output Output is path to output file
	Output string `json:"output" yaml:"output"`

	// Path Path is path within the global data where data are read from (must be container). Those data are set to template engine.When omitted, then root of global data is assumed
	Path *string `json:"path,omitempty" yaml:"path,omitempty"`
}

// TemplateOpSpec TemplateOp can be used to render value from data at runtime
type TemplateOpSpec struct {
	// ParseAs ParseTextAs defines how to parse text.
	//  * none - do not parse, it's just a text (dom.Leaf)
	//  * yaml - parse text as a YAML source into dom.Node
	//  * float64 - parse text as float64 number into dom.Leaf
	//  * int64 - parse text as int64 number into dom.Leaf
	ParseAs *ParseTextAs `json:"parseAs,omitempty" yaml:"parseAs,omitempty"`

	// Path Path within global data tree where to set result at
	Path *ValOrRef `json:"path" yaml:"path"`

	// Template Template to render
	Template string `json:"template" yaml:"template"`

	// Trim When true, whitespace is trimmed off the value
	Trim *bool `json:"trim,omitempty" yaml:"trim,omitempty"`
}

// XmlImportOptions Configuration to customize XML loading. Only relevant for 'xml' mode
type XmlImportOptions struct {
	// Layout Layout defines how XML-specific constructs are laid out into DOM tree.
	//  * default - will produce "Value" leaf for each text node.
	//  Child elements are collected into the list, if their name appears multiple times within the parent, otherwise they are regular child node.
	//  Attributes of element are put into container node "Attrs".
	//  Namespaces are ignored.
	Layout *XmlLayout `json:"layout,omitempty" yaml:"layout,omitempty"`

	// Query xpath expression to use to extract subset from source XML document. When omitted, then "/html" is assumed
	Query *ValOrRef `json:"query,omitempty" yaml:"query,omitempty"`
}

// XmlLayout Layout defines how XML-specific constructs are laid out into DOM tree.
//   - default - will produce "Value" leaf for each text node.
//     Child elements are collected into the list, if their name appears multiple times within the parent, otherwise they are regular child node.
//     Attributes of element are put into container node "Attrs".
//     Namespaces are ignored.
type XmlLayout string
